module libcharmtyles
{
    include "charmtyles/util/AST.hpp";
    include "charmtyles/util/generator.hpp";
    include "Eigen/Core";
    include "limits";

    readonly CProxy_scalar_impl scalar_impl_proxy;

    chare set_future
    {
        entry set_future(ck::future<bool>, int);

        entry [reductiontarget] void mark_complete();

        entry [reductiontarget] void evaluate_bool(bool);
    }

    chare get_vec_future
    {
        entry get_vec_future(ck::future<std::vector<double>>, size_t);

        entry [reductiontarget] void construct_vector(CkReductionMsg *msg);
    }

    chare get_partial_vec_future
    {
        entry get_partial_vec_future(ck::future<std::vector<double>>, size_t);

        entry [reductiontarget] void construct_partial_vector(CkReductionMsg *msg);
    }

    chare get_mat_future
    {
        entry get_mat_future(ck::future<std::vector<std::vector<double>>>, size_t, size_t);

        entry [reductiontarget] void construct_matrix(CkReductionMsg *msg);
    }

    PUPable ct::generator;
    PUPable ct::from_vector_generator;
    PUPable ct::from_matrix_generator;
    PUPable ct::unary_operator;
    PUPable ct::binary_operator;
    PUPable ct::custom_operator;

    chare scalar_impl
    {
        entry scalar_impl();

        entry void main_kernel() {
            for (; SDAG_INDEX > -1;) {
            case {
                // Actual computation kernel
                when add_scalar[SDAG_INDEX](int sdag_index, int scalar_id, double value) {
                serial "add_scalar" {
                    if (scalar_id >= scal_map.size())
                        scal_map.resize(scalar_id + 1);
                    
                    scal_map[scalar_id] = value;

                    ++SDAG_INDEX;
                }} // add_scalar

                when reduction[SDAG_INDEX](double value) {
                    case {
                        when update_scalar[SDAG_INDEX](int sdag_index, int scalar_id) {
                        serial "reduction" {
                            if (scalar_id >= scal_map.size())
                                scal_map.resize(scalar_id + 1);
                            
                            scal_map[scalar_id] = value;

                            ++SDAG_INDEX;
                        }} // update_scalar

                        when norm_update[SDAG_INDEX](int sdag_index, int scalar_id, int p) {
                        serial "norm_update" {
                            if (scalar_id >= scal_map.size())
                                scal_map.resize(scalar_id + 1);
                            
                            value = std::pow(value, 1.0 / static_cast<double>(p));
                            scal_map[scalar_id] = value;

                            ++SDAG_INDEX;
                        }}
                    }
                } // reduction

                when get_value[SDAG_INDEX](int sdag_index, int scalar_id, ck::future<double> fval) {
                serial "get_value" {
                    fval.set(scal_map[scalar_id]);

                    ++SDAG_INDEX;
                }} // get_value

            }} // case + for-loop end
        }

        entry void add_scalar(int, int, double);
        entry [reductiontarget] void reduction(double);
        entry void update_scalar(int, int);
        entry void norm_update(int, int, int);
        entry void get_value(int, int, ck::future<double>);
    }

    array[1D] vector_impl
    {
        entry vector_impl(int, int);   // Number of Partitions, Vector Block Size

        entry void main_kernel() {
            for (; SDAG_INDEX > -1;) {
            case {
                // Generator Init kernel
                when generator_init[SDAG_INDEX](int sdag_idx,
                    int vec_idx, int total_len, std::shared_ptr<ct::generator> gen_ptr) {
                serial "generator_init" {
                    CkAssert((vec_map.size() == vec_idx) &&
                        "A vector is initialized before a dependent vector "
                        "initialization.");

                    std::size_t vec_dim = get_vec_dim(total_len);

                    std::vector<double> gen_vec(vec_dim);

                    for (int dimX = 0; dimX != vec_dim; ++dimX)
                    {
                        gen_vec[dimX] = gen_ptr->generate(thisIndex * vec_block_size + dimX);
                    }
                    vec_map.emplace_back(std::move(gen_vec));

                    ++SDAG_INDEX;
                }}

                // Actual computation kernel
                when compute[SDAG_INDEX](int sdag_index,
                    std::vector<std::vector<ct::vec_impl::vec_node>> instr_list, CProxy_set_future proxy) {
                serial "compute_vector" {
                    // if (thisIndex == 0)
                    //    print_instructions(instr_list);

                    update_partitions(instr_list);

                    CkCallback cb(CkReductionTarget(set_future, mark_complete), proxy);
                    contribute(cb);

                    ++SDAG_INDEX;
                }} // compute

                when compute[SDAG_INDEX](int sdag_index,
                    std::vector<std::vector<ct::vec_impl::vec_node>> instr_list) {
                serial "compute_no_proxy_vector" {
                    // if (thisIndex == 0)
                    //    print_instructions(instr_list);

                    update_partitions(instr_list);

                    ++SDAG_INDEX;
                }} // compute

                when dot[SDAG_INDEX](int sdag_index,
                    int lhs_id, int rhs_id, int scal_sdag_idx) {
                serial "vector_dot" {
                    std::vector<double>& lhs = vec_map[lhs_id];
                    std::vector<double>& rhs = vec_map[rhs_id];

                    Eigen::Map<Eigen::VectorXd> elhs(lhs.data(), lhs.size());
                    Eigen::Map<Eigen::VectorXd> erhs(rhs.data(), rhs.size());

                    double result = elhs.dot(erhs);

                    CkCallback cb(CkReductionTarget(scalar_impl, reduction), scalar_impl_proxy);
                    contribute(sizeof(double), &result, CkReduction::sum_double, cb, scal_sdag_idx);

                    ++SDAG_INDEX;
                }} // dot

                when send_to_matrix[SDAG_INDEX](
                    int sdag_index, int vec_idx, int rhs_sdag_idx, CProxy_matrix_impl proxy) {
                serial "send_to_matrix" {
                    proxy.receive_to_matrix(rhs_sdag_idx, vec_map[vec_idx].size(), vec_map[vec_idx].data());
                
                    ++SDAG_INDEX;
                }} // send to matrix

                when update_index[SDAG_INDEX](int sdag_idx, int vector_idx) {
                when update_vector(int len, double* result) {
                serial "update vector" {
                    // TODO: use vector back_inserter here!
                    if (vector_idx == vec_map.size())
                        vec_map.emplace_back(std::vector<double>(len));

                    std::copy(result, result + len, vec_map[vector_idx].begin());

                    ++SDAG_INDEX;
                }}} // update index + update vector

                when reduce_sum[SDAG_INDEX](int sdag_idx, int vector_id, int scal_sdag_idx) {
                serial "reduce_sum" {
                    std::vector<double>& lhs = vec_map[vector_id];

                    Eigen::Map<Eigen::VectorXd> elhs(lhs.data(), lhs.size());

                    double result = elhs.sum();

                    CkCallback cb(CkReductionTarget(scalar_impl, reduction), scalar_impl_proxy);
                    contribute(sizeof(double), &result, CkReduction::sum_double, cb, scal_sdag_idx);

                    ++SDAG_INDEX;
                }}

                when norm_p[SDAG_INDEX](int sdag_idx, int vector_id, int p, int scal_sdag_idx) {
                serial "norm_p" {
                    std::vector<double>& lhs = vec_map[vector_id];

                    Eigen::Map<Eigen::ArrayXd> elhs(lhs.data(), lhs.size());

                    double result = Eigen::pow(elhs, p).sum();

                    CkCallback cb(CkReductionTarget(scalar_impl, reduction), scalar_impl_proxy);
                    contribute(sizeof(double), &result, CkReduction::sum_double, cb, scal_sdag_idx);

                    ++SDAG_INDEX;
                }}

                when min[SDAG_INDEX](int sdag_idx, int vector_id, int scal_sdag_idx) {
                serial "min" {
                    std::vector<double>& lhs = vec_map[vector_id];

                    Eigen::Map<Eigen::ArrayXd> elhs(lhs.data(), lhs.size());

                    Eigen::Index index;
                    double result = elhs.minCoeff(&index);

                    CkCallback cb(CkReductionTarget(scalar_impl, reduction), scalar_impl_proxy);
                    contribute(sizeof(double), &result, CkReduction::min_double, cb, scal_sdag_idx);

                    ++SDAG_INDEX;
                }}

                when max[SDAG_INDEX](int sdag_idx, int vector_id, int scal_sdag_idx) {
                serial "max" {
                    std::vector<double>& lhs = vec_map[vector_id];

                    Eigen::Map<Eigen::ArrayXd> elhs(lhs.data(), lhs.size());

                    Eigen::Index index;
                    double result = elhs.maxCoeff(&index);

                    CkCallback cb(CkReductionTarget(scalar_impl, reduction), scalar_impl_proxy);
                    contribute(sizeof(double), &result, CkReduction::max_double, cb, scal_sdag_idx);

                    ++SDAG_INDEX;
                }}

                when synchronize[SDAG_INDEX](int sdag_index, CProxy_set_future proxy) {
                serial "synchronize" {
                    CkCallback cb(CkReductionTarget(set_future, mark_complete), proxy);
                    contribute(cb);

                    ++SDAG_INDEX;
                }}

                when get_value[SDAG_INDEX](int sdag_index, int vector_id, CProxy_get_vec_future proxy) {
                serial "get_value" {
                    std::size_t vec_size = vec_map[vector_id].size();
                    size_t index = thisIndex*vec_block_size;

                    std::vector<double> arr_portion(vec_size + 1);
                    arr_portion[0] = static_cast<double>(index);
                    std::copy(vec_map[vector_id].begin(), vec_map[vector_id].end(), arr_portion.begin() + 1);
                    
                    CkCallback cb(CkReductionTarget(get_vec_future, construct_vector), proxy);
                    contribute(arr_portion, CkReduction::set, cb);
                    ++SDAG_INDEX;
                }} // get_value

                when all[SDAG_INDEX](int sdag_index, int vector_id, CProxy_set_future proxy) {
                serial "all" {
                    bool res = std::all_of(vec_map[vector_id].begin(), vec_map[vector_id].end(), 
                      [](double val) { return val != 0.0; });
                    
                    CkCallback cb(CkReductionTarget(set_future, evaluate_bool), proxy);
                    contribute(sizeof(bool), &res, CkReduction::logical_and_bool, cb);
                    ++SDAG_INDEX;
                }} // all

                when any[SDAG_INDEX](int sdag_index, int vector_id, CProxy_set_future proxy) {
                serial "any" {
                    bool res = std::any_of(vec_map[vector_id].begin(), vec_map[vector_id].end(), 
                      [](double val) { return val != 0.0; });
                    
                    CkCallback cb(CkReductionTarget(set_future, evaluate_bool), proxy);
                    contribute(sizeof(bool), &res, CkReduction::logical_or_bool, cb);
                    ++SDAG_INDEX;
                }} // any

                when get_partial_value[SDAG_INDEX](int sdag_index, int vector_id, int k, int n, CProxy_get_partial_vec_future proxy) {
                serial "get_partial_value" {
                    size_t start_index = thisIndex * vec_block_size;
                    size_t end_index = start_index + vec_map[vector_id].size();
                    
                    
                    double stride = static_cast<double>(n) / static_cast<double>(k);
                    
                   
                    std::vector<std::pair<size_t, double>> samples;
                    
                    for (int i = 0; i < k; ++i) {
                        size_t global_index = static_cast<size_t>(i * stride);
                        
                        // Check if this global index falls within chares range
                        if (global_index >= start_index && global_index < end_index) {
                            size_t local_index = global_index - start_index;
                            samples.push_back({static_cast<size_t>(i), vec_map[vector_id][local_index]});
                        }
                    }
                    
                    if (!samples.empty()) {
                        // [count, sample_index1, value1, sample_index2, value2, ...]
                        std::vector<double> arr_portion(1 + 2 * samples.size());
                        arr_portion[0] = static_cast<double>(samples.size());
                        
                        for (size_t i = 0; i < samples.size(); ++i) {
                            arr_portion[1 + 2*i] = static_cast<double>(samples[i].first);      // sample index (0..k-1)
                            arr_portion[1 + 2*i + 1] = samples[i].second;                     // value
                        }
                        
                        CkCallback cb(CkReductionTarget(get_partial_vec_future, construct_partial_vector), proxy);
                        contribute(arr_portion, CkReduction::set, cb);
                    } else {
                        // contribute empty
                        CkCallback cb(CkReductionTarget(get_partial_vec_future, construct_partial_vector), proxy);
                        contribute(0, (double*)NULL, CkReduction::set, cb);
                    }
                    ++SDAG_INDEX;
                }} // get_partial_value

                when get_avg_partial[SDAG_INDEX](int sdag_index, int vector_id, int k, int n, int scal_sdag_idx) {
                serial "get_avg_partial" {
                    size_t start_index = thisIndex * vec_block_size;
                    size_t end_index = start_index + vec_map[vector_id].size();
                    
                    
                    double stride = static_cast<double>(n) / static_cast<double>(k);
                    
                    
                    std::vector<std::pair<size_t, double>> samples;
                    
                    for (int i = 0; i < k; ++i) {
                        size_t global_index = static_cast<size_t>(i * stride);
                        
                        // Check if this global index falls within chares range
                        if (global_index >= start_index && global_index < end_index) {
                            size_t local_index = global_index - start_index;
                            samples.push_back({static_cast<size_t>(i), vec_map[vector_id][local_index]});
                        }
                    }
                    
                    double result = 0.0;
                    if (!samples.empty()) {
                        // Compute average
                        for (const auto& sample : samples) {
                            result += sample.second;
                        }
                        result /= static_cast<double>(samples.size());
                    }
                    
                    CkCallback cb(CkReductionTarget(scalar_impl, reduction), scalar_impl_proxy);
                    contribute(sizeof(double), &result, CkReduction::sum_double, cb, scal_sdag_idx);

                    ++SDAG_INDEX;
                }} // get_avg_partial

                when get_max_partial[SDAG_INDEX](int sdag_index, int vector_id, int k, int n, int scal_sdag_idx) {
                serial "get_max_partial" {
                    size_t start_index = thisIndex * vec_block_size;
                    size_t end_index = start_index + vec_map[vector_id].size();
                    
                    
                    double stride = static_cast<double>(n) / static_cast<double>(k);
                    
                    
                    std::vector<std::pair<size_t, double>> samples;
                    
                    for (int i = 0; i < k; ++i) {
                        size_t global_index = static_cast<size_t>(i * stride);
                        
                        // Check if this global index falls within chares range
                        if (global_index >= start_index && global_index < end_index) {
                            size_t local_index = global_index - start_index;
                            samples.push_back({static_cast<size_t>(i), vec_map[vector_id][local_index]});
                        }
                    }
                    
                    double result = std::numeric_limits<double>::lowest();
                    if (!samples.empty()) {
                        // Find maximum
                        for (const auto& sample : samples) {
                            result = std::max(result, sample.second);
                        }
                    }
                    
                    CkCallback cb(CkReductionTarget(scalar_impl, reduction), scalar_impl_proxy);
                    contribute(sizeof(double), &result, CkReduction::max_double, cb, scal_sdag_idx);

                    ++SDAG_INDEX;
                }} // get_max_partial

                when get_min_partial[SDAG_INDEX](int sdag_index, int vector_id, int k, int n, int scal_sdag_idx) {
                serial "get_min_partial" {
                    size_t start_index = thisIndex * vec_block_size;
                    size_t end_index = start_index + vec_map[vector_id].size();
                    
                    
                    double stride = static_cast<double>(n) / static_cast<double>(k);
                    
                    
                    std::vector<std::pair<size_t, double>> samples;
                    
                    for (int i = 0; i < k; ++i) {
                        size_t global_index = static_cast<size_t>(i * stride);
                        
                        // Check if this global index falls within chares range
                        if (global_index >= start_index && global_index < end_index) {
                            size_t local_index = global_index - start_index;
                            samples.push_back({static_cast<size_t>(i), vec_map[vector_id][local_index]});
                        }
                    }
                    
                    double result = std::numeric_limits<double>::max();
                    if (!samples.empty()) {
                        // Find minimum
                        for (const auto& sample : samples) {
                            result = std::min(result, sample.second);
                        }
                    }
                    
                    CkCallback cb(CkReductionTarget(scalar_impl, reduction), scalar_impl_proxy);
                    contribute(sizeof(double), &result, CkReduction::min_double, cb, scal_sdag_idx);

                    ++SDAG_INDEX;
                }} // get_min_partial

                // Chunk-based statistics methods
                when get_avg_chunks[SDAG_INDEX](int sdag_index, int vector_id, int k, int n, CProxy_get_partial_vec_future proxy) {
                serial "get_avg_chunks" {
                    size_t start_index = thisIndex * vec_block_size;
                    size_t end_index = start_index + vec_map[vector_id].size();
                    
                    
                    size_t base_chunk_size = n / k;
                    size_t remainder = n % k;
                    
                    
                    std::vector<std::pair<size_t, double>> chunk_data;  
                    
                    
                    for (int chunk_id = 0; chunk_id < k; ++chunk_id) {
                        // chunk boundaries
                        size_t chunk_start = chunk_id * base_chunk_size;
                        size_t chunk_end;
                        if (chunk_id == k - 1) {
                            chunk_end = chunk_start + base_chunk_size + remainder;  
                        } else {
                            chunk_end = chunk_start + base_chunk_size;
                        }
                        
                        
                        size_t intersect_start = std::max(chunk_start, start_index);
                        size_t intersect_end = std::min(chunk_end, end_index);
                        
                        if (intersect_start < intersect_end) {
                            
                            double sum = 0.0;
                            int count = 0;
                            for (size_t global_idx = intersect_start; global_idx < intersect_end; ++global_idx) {
                                size_t local_idx = global_idx - start_index;
                                sum += vec_map[vector_id][local_idx];
                                count++;
                            }
                            if (count > 0) {
                                double avg = sum / count;
                                chunk_data.push_back({static_cast<size_t>(chunk_id), avg});
                            }
                        }
                    }
                    
                    if (!chunk_data.empty()) {
                        // [count, chunk_id1, avg1, chunk_id2, avg2, ...]
                        std::vector<double> arr_portion(1 + 2 * chunk_data.size());
                        arr_portion[0] = static_cast<double>(chunk_data.size());
                        
                        for (size_t i = 0; i < chunk_data.size(); ++i) {
                            arr_portion[1 + 2*i] = static_cast<double>(chunk_data[i].first);      
                            arr_portion[1 + 2*i + 1] = chunk_data[i].second;                     
                        }
                        
                        CkCallback cb(CkReductionTarget(get_partial_vec_future, construct_partial_vector), proxy);
                        contribute(arr_portion, CkReduction::set, cb);
                    } else {
                        
                        CkCallback cb(CkReductionTarget(get_partial_vec_future, construct_partial_vector), proxy);
                        contribute(0, (double*)NULL, CkReduction::set, cb);
                    }

                    ++SDAG_INDEX;
                }} // get_avg_chunks

                when get_max_chunks[SDAG_INDEX](int sdag_index, int vector_id, int k, int n, CProxy_get_partial_vec_future proxy) {
                serial "get_max_chunks" {
                    size_t start_index = thisIndex * vec_block_size;
                    size_t end_index = start_index + vec_map[vector_id].size();
                    
                    
                    size_t base_chunk_size = n / k;
                    size_t remainder = n % k;
                    
                    
                    std::vector<std::pair<size_t, double>> chunk_data;  
                    
                   
                    for (int chunk_id = 0; chunk_id < k; ++chunk_id) {
                        // chunk boundaries
                        size_t chunk_start = chunk_id * base_chunk_size;
                        size_t chunk_end;
                        if (chunk_id == k - 1) {
                            chunk_end = chunk_start + base_chunk_size + remainder;  
                        } else {
                            chunk_end = chunk_start + base_chunk_size;
                        }
                        
                        
                        size_t intersect_start = std::max(chunk_start, start_index);
                        size_t intersect_end = std::min(chunk_end, end_index);
                        
                        if (intersect_start < intersect_end) {
                            
                            double max_val = std::numeric_limits<double>::lowest();
                            for (size_t global_idx = intersect_start; global_idx < intersect_end; ++global_idx) {
                                size_t local_idx = global_idx - start_index;
                                max_val = std::max(max_val, vec_map[vector_id][local_idx]);
                            }
                            chunk_data.push_back({static_cast<size_t>(chunk_id), max_val});
                        }
                    }
                    
                    if (!chunk_data.empty()) {
                        // Format: [count, chunk_id1, max1, chunk_id2, max2, ...]
                        std::vector<double> arr_portion(1 + 2 * chunk_data.size());
                        arr_portion[0] = static_cast<double>(chunk_data.size());
                        
                        for (size_t i = 0; i < chunk_data.size(); ++i) {
                            arr_portion[1 + 2*i] = static_cast<double>(chunk_data[i].first);      
                            arr_portion[1 + 2*i + 1] = chunk_data[i].second;                    
                        }
                        
                        CkCallback cb(CkReductionTarget(get_partial_vec_future, construct_partial_vector), proxy);
                        contribute(arr_portion, CkReduction::set, cb);
                    } else {
                        
                        CkCallback cb(CkReductionTarget(get_partial_vec_future, construct_partial_vector), proxy);
                        contribute(0, (double*)NULL, CkReduction::set, cb);
                    }

                    ++SDAG_INDEX;
                }} // get_max_chunks

                when get_min_chunks[SDAG_INDEX](int sdag_index, int vector_id, int k, int n, CProxy_get_partial_vec_future proxy) {
                serial "get_min_chunks" {
                    size_t start_index = thisIndex * vec_block_size;
                    size_t end_index = start_index + vec_map[vector_id].size();
                    
                    
                    size_t base_chunk_size = n / k;
                    size_t remainder = n % k;
                    
                    
                    std::vector<std::pair<size_t, double>> chunk_data;  
                    
                   
                    for (int chunk_id = 0; chunk_id < k; ++chunk_id) {
                        
                        size_t chunk_start = chunk_id * base_chunk_size;
                        size_t chunk_end;
                        if (chunk_id == k - 1) {
                            chunk_end = chunk_start + base_chunk_size + remainder;  
                        } else {
                            chunk_end = chunk_start + base_chunk_size;
                        }
                        
                        
                        size_t intersect_start = std::max(chunk_start, start_index);
                        size_t intersect_end = std::min(chunk_end, end_index);
                        
                        if (intersect_start < intersect_end) {
                            
                            double min_val = std::numeric_limits<double>::max();
                            for (size_t global_idx = intersect_start; global_idx < intersect_end; ++global_idx) {
                                size_t local_idx = global_idx - start_index;
                                min_val = std::min(min_val, vec_map[vector_id][local_idx]);
                            }
                            chunk_data.push_back({static_cast<size_t>(chunk_id), min_val});
                        }
                    }
                    
                    if (!chunk_data.empty()) {
                        // Format: [count, chunk_id1, min1, chunk_id2, min2, ...]
                        std::vector<double> arr_portion(1 + 2 * chunk_data.size());
                        arr_portion[0] = static_cast<double>(chunk_data.size());
                        
                        for (size_t i = 0; i < chunk_data.size(); ++i) {
                            arr_portion[1 + 2*i] = static_cast<double>(chunk_data[i].first);     
                            arr_portion[1 + 2*i + 1] = chunk_data[i].second;                     
                        }
                        
                        CkCallback cb(CkReductionTarget(get_partial_vec_future, construct_partial_vector), proxy);
                        contribute(arr_portion, CkReduction::set, cb);
                    } else {
                        
                        CkCallback cb(CkReductionTarget(get_partial_vec_future, construct_partial_vector), proxy);
                        contribute(0, (double*)NULL, CkReduction::set, cb);
                    }

                    ++SDAG_INDEX;
                }} // get_min_chunks
            }}
        }

        entry void generator_init(int, int, int, std::shared_ptr<ct::generator>);

        entry void compute(int, std::vector<std::vector<ct::vec_impl::vec_node>>, CProxy_set_future);
        entry void compute(int, std::vector<std::vector<ct::vec_impl::vec_node>>);
        entry void dot(int, int, int, int);
        entry void send_to_matrix(int, int, int, CProxy_matrix_impl);
        entry [reductiontarget] void update_vector(int len, double result[len]);
        entry void update_index(int, int);
        entry void reduce_sum(int, int, int);
        entry void norm_p(int, int, int, int);
        entry void min(int, int, int);
        entry void max(int, int, int);
        entry void synchronize(int, CProxy_set_future);
        entry void get_value(int, int, CProxy_get_vec_future);
        entry void all(int sdag_index, int vector_id, CProxy_set_future proxy);
        entry void any(int sdag_index, int vector_id, CProxy_set_future proxy);
        entry void get_partial_value(int, int, int, int, CProxy_get_partial_vec_future);
        entry void get_avg_partial(int, int, int, int, int);
        entry void get_max_partial(int, int, int, int, int);
        entry void get_min_partial(int, int, int, int, int);
        entry void get_avg_chunks(int, int, int, int, CProxy_get_partial_vec_future);
        entry void get_max_chunks(int, int, int, int, CProxy_get_partial_vec_future);
        entry void get_min_chunks(int, int, int, int, CProxy_get_partial_vec_future);
    }

    array[2D] matrix_impl
    {
        entry matrix_impl(int, int, int, int); // Num Chares y, Num Chares x; Block Row Len, Block Col Len
    
        entry void main_kernel() {
            for (; SDAG_INDEX > -1;) {
            case {

                // Generator Init kernel
                when generator_init[SDAG_INDEX](
                    int sdag_index, int node_id, int total_rows, int total_cols, std::shared_ptr<ct::generator> gen_ptr) {
                serial "generator_init" {
                    CkAssert((mat_map.size() == node_id) &&
                        "A matrix is initialized before a dependent matrix "
                        "initialization.");

                    std::size_t num_rows = get_mat_rows(total_rows);
                    std::size_t num_cols = get_mat_cols(total_cols);

                    ct::util::matrix_view mat{num_rows, num_cols};
                    for (int row_id = 0; row_id != num_rows; ++row_id)
                    {
                        for (int col_id = 0; col_id != num_cols; ++col_id)
                        {
                            mat(row_id, col_id) = gen_ptr->generate(
                                thisIndex.y * row_block_len + row_id, thisIndex.x * col_block_len + col_id);
                        }
                    }
                    mat_map.emplace_back(std::move(mat));

                    ++SDAG_INDEX;
                }}

                // Actual computational kernel
                when compute[SDAG_INDEX](int sdag_index,
                    std::vector<std::vector<ct::mat_impl::mat_node>> instr_list, CProxy_set_future proxy) {
                serial "compute_matrix" {

                    update_partitions(instr_list);

                    CkCallback cb(CkReductionTarget(set_future, mark_complete), proxy);
                    contribute(cb);

                    ++SDAG_INDEX;
                }}

                when compute[SDAG_INDEX](int sdag_index,
                    std::vector<std::vector<ct::mat_impl::mat_node>> instr_list) {
                serial "compute_no_proxy_matrix" {

                    update_partitions(instr_list);

                    ++SDAG_INDEX;
                }} // fused compute kernel

                when synchronize[SDAG_INDEX](int sdag_index, CProxy_set_future proxy) {
                serial "synchronize" {
                    CkCallback cb(CkReductionTarget(set_future, mark_complete), proxy);
                    contribute(cb);

                    ++SDAG_INDEX;
                }}

                when mat_vec_dot[SDAG_INDEX](
                    int sdag_index, int mat_idx, int result_sdag_idx,
                    CProxy_vector_impl result_proxy, int result_vec_idx, int result_size) {
                    when receive_to_matrix[SDAG_INDEX](int sdag_idx, int len, double* data)
                serial "mat_vec_dot" {

                    // Get the subvector indices
                    std::size_t block_dim = col_block_len;
                    std::size_t vec_size = block_dim;
                    if (thisIndex.x == num_chares_x - 1 && block_dim % col_block_len != 0) {
                        vec_size = len % col_block_len;
                    }

                    Eigen::Map<Eigen::VectorXd> elhs(data + thisIndex.x * block_dim, vec_size);
                    Eigen::Map<Eigen::MatrixXd> 
                        erhs(mat_map[mat_idx].data(), mat_map[mat_idx].rows(), mat_map[mat_idx].cols());
                    
                    double result[result_size];
                    for (int i = 0; i != result_size; ++i)
                        result[i] = 0;

                    Eigen::Map<Eigen::VectorXd> eres(result + thisIndex.y * row_block_len, mat_map[mat_idx].rows());
                    eres = erhs * elhs;

                    // TODO: Use Section Reduction!
                    CkCallback cb(CkReductionTarget(vector_impl, update_vector), result_proxy);
                    contribute((result_size) * sizeof(double), result, CkReduction::sum_double, cb);

                    ++SDAG_INDEX;
                }} // matrix vector dot product

                when vec_mat_dot[SDAG_INDEX](
                    int sdag_index, int mat_idx, int result_sdag_idx,
                    CProxy_vector_impl result_proxy, int result_vec_idx, int result_size) {
                    when receive_to_matrix[SDAG_INDEX](int sdag_idx, int len, double* data)
                serial "vec_mat_dot" {

                    // Get the subvector indices
                    std::size_t block_dim = row_block_len;
                    std::size_t vec_size = block_dim;
                    if (thisIndex.y == num_chares_y - 1 && block_dim % row_block_len != 0) {
                        vec_size = len % row_block_len;
                    }

                    Eigen::Map<Eigen::VectorXd> elhs(data + thisIndex.y * block_dim, vec_size);
                    Eigen::Map<Eigen::MatrixXd> 
                        erhs(mat_map[mat_idx].data(), mat_map[mat_idx].rows(), mat_map[mat_idx].cols());
                    
                    double result[result_size];
                    for (int i = 0; i != result_size; ++i)
                        result[i] = 0;

                    Eigen::Map<Eigen::VectorXd> eres(result + thisIndex.x * col_block_len, mat_map[mat_idx].cols());
                    eres = elhs * erhs;

                    // TODO: Use Section Reduction!
                    CkCallback cb(CkReductionTarget(vector_impl, update_vector), result_proxy);
                    contribute((result_size) * sizeof(double), result, CkReduction::sum_double, cb);

                    ++SDAG_INDEX;
                }} // vector matrix dot product

                when mat_mat_mul[SDAG_INDEX](
                    int sdag_index, int mat_idx, int mat_A_idx, int mat_B_idx) {
                    serial "initial_send" {
                        double* data_A = mat_map[mat_A_idx].data();
                        std::size_t rows_A = mat_map[mat_A_idx].rows();
                        std::size_t cols_A = mat_map[mat_A_idx].cols();
                        thisProxy((thisIndex.x-thisIndex.y+num_chares_y)%num_chares_x, thisIndex.y).inputA(0, data_A, rows_A, cols_A);

                        double* data_B = mat_map[mat_B_idx].data();
                        std::size_t rows_B = mat_map[mat_B_idx].rows();
                        std::size_t cols_B = mat_map[mat_B_idx].cols();
                        thisProxy(thisIndex.x, (thisIndex.y-thisIndex.x+num_chares_x)%num_chares_y).inputB(0, data_B, rows_B, cols_B);
                    }
                    // For all block
                    // FIXME:
                    // Current implementation expects square matrix!
                    forall [block] (0:num_chares_x-1,1) {
                        when
                        inputA[block](int blockIdA, double blockA[M*KA], unsigned int M, unsigned int KA),
                        inputB[block](int blockIdB, double blockB[KB*N], unsigned int KB, unsigned int N)
                        serial "mat_mul_kernel" {
                            CkAssert(KA == KB);

                            Eigen::Map<Eigen::MatrixXd> matA(blockA, M, KA);
                            Eigen::Map<Eigen::MatrixXd> matB(blockB, KB, N);

                            ct::util::matrix_view& result_mat = mat_map[mat_idx];
                            Eigen::Map<Eigen::MatrixXd> matC(result_mat.data(), result_mat.rows(), result_mat.cols());

                            matC += matA * matB;

                            if (blockIdA != num_chares_x) {
                                int destX = (thisIndex.x + 1) % num_chares_x;
                                int destY = thisIndex.y;
                                thisProxy(destX, destY).inputA(blockIdA+1, blockA, M, KA);
                            }
                            if (blockIdB != num_chares_y) {
                                int destX = thisIndex.x;
                                int destY = (thisIndex.y + 1) % num_chares_y;
                                thisProxy(destX, destY).inputB(blockIdB+1, blockB, KB, N);
                            }
                        }
                    }
                    serial "mat_mul_end" {
                        block = 0;
                        ++SDAG_INDEX;
                    }
                }

                when reduce_sum[SDAG_INDEX](int sdag_idx, int matrix_id, int scal_sdag_idx) {
                serial "reduce_sum" {
                    ct::util::matrix_view& lhs = mat_map[matrix_id];

                    Eigen::Map<Eigen::MatrixXd> elhs(lhs.data(), lhs.rows(), lhs.cols());

                    double result = elhs.sum();

                    CkCallback cb(CkReductionTarget(scalar_impl, reduction), scalar_impl_proxy);
                    contribute(sizeof(double), &result, CkReduction::sum_double, cb, scal_sdag_idx);

                    ++SDAG_INDEX;
                }}

                when get_value[SDAG_INDEX](int sdag_index, int matrix_id, CProxy_get_mat_future proxy) {
                serial "get_value" {
                    ct::util::matrix_view& mat = mat_map[matrix_id];
                    size_t row_size = mat.rows();
                    size_t col_size = mat.cols();

                    size_t row_index = thisIndex.y*col_block_len;
                    size_t col_index = thisIndex.x*row_block_len;

                    std::vector<double> arr_portion(row_size*col_size + 3);
                    arr_portion[0] = static_cast<double>(row_index);
                    arr_portion[1] = static_cast<double>(col_index);
                    arr_portion[2] = static_cast<double>(row_size);
                    std::copy(mat.data(), mat.data()+(row_size*col_size), arr_portion.begin() + 3);
                    
                    CkCallback cb(CkReductionTarget(get_mat_future, construct_matrix), proxy);
                    contribute(arr_portion, CkReduction::set, cb);
                    ++SDAG_INDEX;
                }} // get_value

                when any[SDAG_INDEX](int sdag_index, int matrix_id, CProxy_set_future proxy) {
                serial "any" {
                    ct::util::matrix_view& mat = mat_map[matrix_id];
                    size_t row_size = mat.rows();
                    size_t col_size = mat.cols();

                    bool res = std::any_of(mat.data(), mat.data()+(row_size*col_size), 
                      [](double val) { return val != 0.0; });
                    
                    CkCallback cb(CkReductionTarget(set_future, evaluate_bool), proxy);
                    contribute(sizeof(bool), &res , CkReduction::logical_or_bool, cb);
                    ++SDAG_INDEX;
                }} // any

                when all[SDAG_INDEX](int sdag_index, int matrix_id, CProxy_set_future proxy) {
                serial "all" {
                    ct::util::matrix_view& mat = mat_map[matrix_id];
                    size_t row_size = mat.rows();
                    size_t col_size = mat.cols();

                    bool res = std::all_of(mat.data(), mat.data()+(row_size*col_size), 
                      [](double val) { return val != 0.0; });
                    
                    CkCallback cb(CkReductionTarget(set_future, evaluate_bool), proxy);
                    contribute(sizeof(bool), &res, CkReduction::logical_and_bool, cb);
                    ++SDAG_INDEX;
                }} // any
            }}
        }

        entry void mat_mat_mul(int, int, int, int);
        entry void inputA(int, double blockA[M*KA], unsigned int M, unsigned int KA);
        entry void inputB(int, double blockB[KB*N], unsigned int KB, unsigned int N);

        entry void generator_init(int, int, int, int, std::shared_ptr<ct::generator>);
        entry void compute(int, std::vector<std::vector<ct::mat_impl::mat_node>>, CProxy_set_future);
        entry void compute(int, std::vector<std::vector<ct::mat_impl::mat_node>>);
        entry void synchronize(int, CProxy_set_future);
        
        entry void mat_vec_dot(int, int, int, CProxy_vector_impl, int, int);
        entry void vec_mat_dot(int, int, int, CProxy_vector_impl, int, int);
        entry void receive_to_matrix(int, int len, double data[len]);

        entry void reduce_sum(int, int, int);
        entry void get_value(int sdag_index, int matrix_id, CProxy_get_mat_future proxy);
        entry void any(int sdag_index, int matrix_id, CProxy_set_future proxy);
        entry void all(int sdag_index, int matrix_id, CProxy_set_future proxy);
    }
}
