module libcharmtyles
{
    include "charmtyles/util/AST.hpp";
    include "charmtyles/util/generator.hpp";
    include "Eigen/Core";

    readonly CProxy_scalar_impl scalar_impl_proxy;

    chare set_future
    {
        entry set_future(ck::future<bool>, int);

        entry [reductiontarget] void mark_complete();
    }

    PUPable ct::generator;
    PUPable ct::unary_operator;

    chare scalar_impl
    {
        entry scalar_impl();

        entry void main_kernel() {
            for (; SDAG_INDEX > -1;) {
            case {
                // Actual computation kernel
                when add_scalar[SDAG_INDEX](int sdag_index, int scalar_id, double value) {
                serial "add_scalar" {
                    if (scalar_id >= scal_map.size())
                        scal_map.resize(scalar_id + 1);
                    
                    scal_map[scalar_id] = value;

                    ++SDAG_INDEX;
                }} // add_scalar

                when reduction[SDAG_INDEX](double value) {
                    case {
                        when update_scalar[SDAG_INDEX](int sdag_index, int scalar_id) {
                        serial "reduction" {
                            if (scalar_id >= scal_map.size())
                                scal_map.resize(scalar_id + 1);
                            
                            scal_map[scalar_id] = value;

                            ++SDAG_INDEX;
                        }} // update_scalar

                        when norm_update[SDAG_INDEX](int sdag_index, int scalar_id, int p) {
                        serial "norm_update" {
                            if (scalar_id >= scal_map.size())
                                scal_map.resize(scalar_id + 1);
                            
                            value = std::pow(value, 1.0 / static_cast<double>(p));
                            scal_map[scalar_id] = value;

                            ++SDAG_INDEX;
                        }}
                    }
                } // reduction

                when get_value[SDAG_INDEX](int sdag_index, int scalar_id, ck::future<double> fval) {
                serial "get_value" {
                    fval.set(scal_map[scalar_id]);

                    ++SDAG_INDEX;
                }} // get_value

            }} // case + for-loop end
        }

        entry void add_scalar(int, int, double);
        entry [reductiontarget] void reduction(double);
        entry void update_scalar(int, int);
        entry void norm_update(int, int, int);
        entry void get_value(int, int, ck::future<double>);
    }

    array[1D] vector_impl
    {
        entry vector_impl(int, int);   // Number of Partitions, Vector Block Size

        entry void main_kernel() {
            for (; SDAG_INDEX > -1;) {
            case {
                // Generator Init kernel
                when generator_init[SDAG_INDEX](int sdag_idx,
                    int vec_idx, int total_len, std::shared_ptr<ct::generator> gen_ptr) {
                serial "generator_init" {
                    CkAssert((vec_map.size() + 1 == node_id) &&
                        "A vector is initialized before a dependent vector "
                        "initialization.");

                    std::size_t vec_dim = get_vec_dim(total_len);

                    std::vector<double> gen_vec(vec_dim);

                    for (int dimX = 0; dimX != vec_dim; ++dimX)
                    {
                        gen_vec[dimX] = gen_ptr->generate(thisIndex * vec_block_size + dimX);
                    }
                    vec_map.emplace_back(std::move(gen_vec));

                    ++SDAG_INDEX;
                }}

                // Actual computation kernel
                when compute[SDAG_INDEX](int sdag_index,
                    std::vector<std::vector<ct::vec_impl::vec_node>> instr_list, CProxy_set_future proxy) {
                serial "compute_vector" {
                    // if (thisIndex == 0)
                    //    print_instructions(instr_list);

                    update_partitions(instr_list);

                    CkCallback cb(CkReductionTarget(set_future, mark_complete), proxy);
                    contribute(cb);

                    ++SDAG_INDEX;
                }} // compute

                when compute[SDAG_INDEX](int sdag_index,
                    std::vector<std::vector<ct::vec_impl::vec_node>> instr_list) {
                serial "compute_no_proxy_vector" {
                    // if (thisIndex == 0)
                    //    print_instructions(instr_list);

                    update_partitions(instr_list);

                    ++SDAG_INDEX;
                }} // compute

                when dot[SDAG_INDEX](int sdag_index,
                    int lhs_id, int rhs_id, int scal_sdag_idx) {
                serial "vector_dot" {
                    std::vector<double>& lhs = vec_map[lhs_id];
                    std::vector<double>& rhs = vec_map[rhs_id];

                    Eigen::Map<Eigen::VectorXd> elhs(lhs.data(), lhs.size());
                    Eigen::Map<Eigen::VectorXd> erhs(rhs.data(), rhs.size());

                    double result = elhs.dot(erhs);

                    CkCallback cb(CkReductionTarget(scalar_impl, reduction), scalar_impl_proxy);
                    contribute(sizeof(double), &result, CkReduction::sum_double, cb, scal_sdag_idx);

                    ++SDAG_INDEX;
                }} // dot

                when send_to_matrix[SDAG_INDEX](
                    int sdag_index, int vec_idx, int rhs_sdag_idx, CProxy_matrix_impl proxy) {
                serial "send_to_matrix" {
                    proxy.receive_to_matrix(rhs_sdag_idx, vec_map[vec_idx].size(), vec_map[vec_idx].data());
                
                    ++SDAG_INDEX;
                }} // send to matrix

                when update_index[SDAG_INDEX](int sdag_idx, int vector_idx) {
                when update_vector(int len, double* result) {
                serial "update vector" {
                    // TODO: use vector back_inserter here!
                    if (vector_idx == vec_map.size())
                        vec_map.emplace_back(std::vector<double>(len));

                    std::copy(result, result + len, vec_map[vector_idx].begin());

                    ++SDAG_INDEX;
                }}} // update index + update vector

                when reduce_sum[SDAG_INDEX](int sdag_idx, int vector_id, int scal_sdag_idx) {
                serial "reduce_sum" {
                    std::vector<double>& lhs = vec_map[vector_id];

                    Eigen::Map<Eigen::VectorXd> elhs(lhs.data(), lhs.size());

                    double result = elhs.sum();

                    CkCallback cb(CkReductionTarget(scalar_impl, reduction), scalar_impl_proxy);
                    contribute(sizeof(double), &result, CkReduction::sum_double, cb, scal_sdag_idx);

                    ++SDAG_INDEX;
                }}

                when norm_p[SDAG_INDEX](int sdag_idx, int vector_id, int p, int scal_sdag_idx) {
                serial "norm_p" {
                    std::vector<double>& lhs = vec_map[vector_id];

                    Eigen::Map<Eigen::ArrayXd> elhs(lhs.data(), lhs.size());

                    double result = Eigen::pow(elhs, p).sum();

                    CkCallback cb(CkReductionTarget(scalar_impl, reduction), scalar_impl_proxy);
                    contribute(sizeof(double), &result, CkReduction::sum_double, cb, scal_sdag_idx);

                    ++SDAG_INDEX;
                }}

                when min[SDAG_INDEX](int sdag_idx, int vector_id, int scal_sdag_idx) {
                serial "min" {
                    std::vector<double>& lhs = vec_map[vector_id];

                    Eigen::Map<Eigen::ArrayXd> elhs(lhs.data(), lhs.size());

                    Eigen::Index index;
                    double result = elhs.minCoeff(&index);

                    CkCallback cb(CkReductionTarget(scalar_impl, reduction), scalar_impl_proxy);
                    contribute(sizeof(double), &result, CkReduction::min_double, cb, scal_sdag_idx);

                    ++SDAG_INDEX;
                }}

                when max[SDAG_INDEX](int sdag_idx, int vector_id, int scal_sdag_idx) {
                serial "max" {
                    std::vector<double>& lhs = vec_map[vector_id];

                    Eigen::Map<Eigen::ArrayXd> elhs(lhs.data(), lhs.size());

                    Eigen::Index index;
                    double result = elhs.maxCoeff(&index);

                    CkCallback cb(CkReductionTarget(scalar_impl, reduction), scalar_impl_proxy);
                    contribute(sizeof(double), &result, CkReduction::max_double, cb, scal_sdag_idx);

                    ++SDAG_INDEX;
                }}

                when synchronize[SDAG_INDEX](int sdag_index, CProxy_set_future proxy) {
                serial "synchronize" {
                    CkCallback cb(CkReductionTarget(set_future, mark_complete), proxy);
                    contribute(cb);

                    ++SDAG_INDEX;
                }}

            }} // case + for-loop end
        }

        entry void generator_init(int, int, int, std::shared_ptr<ct::generator>);

        entry void compute(int, std::vector<std::vector<ct::vec_impl::vec_node>>, CProxy_set_future);
        entry void compute(int, std::vector<std::vector<ct::vec_impl::vec_node>>);
        entry void dot(int, int, int, int);
        entry void send_to_matrix(int, int, int, CProxy_matrix_impl);
        entry [reductiontarget] void update_vector(int len, double result[len]);
        entry void update_index(int, int);
        entry void reduce_sum(int, int, int);
        entry void norm_p(int, int, int, int);
        entry void min(int, int, int);
        entry void max(int, int, int);
        entry void synchronize(int, CProxy_set_future);
    }

    array[2D] matrix_impl
    {
        entry matrix_impl(int, int, int, int); // Num Chares y, Num Chares x; Block Row Len, Block Col Len
    
        entry void main_kernel() {
            for (; SDAG_INDEX > -1;) {
            case {

                // Generator Init kernel
                when generator_init[SDAG_INDEX](
                    int sdag_index, int node_id, int total_rows, int total_cols, std::shared_ptr<ct::generator> gen_ptr) {
                serial "generator_init" {
                    CkAssert((mat_map.size() + 1 == node_id) &&
                        "A matrix is initialized before a dependent matrix "
                        "initialization.");

                    std::size_t num_rows = get_mat_rows(total_rows);
                    std::size_t num_cols = get_mat_cols(total_cols);

                    ct::util::matrix_view mat{num_rows, num_cols};
                    for (int row_id = 0; row_id != num_rows; ++row_id)
                    {
                        for (int col_id = 0; col_id != num_cols; ++col_id)
                        {
                            mat(row_id, col_id) = gen_ptr->generate(
                                thisIndex.y * row_block_len + row_id, thisIndex.x * col_block_len + col_id);
                        }
                    }
                    mat_map.emplace_back(std::move(mat));

                    ++SDAG_INDEX;
                }}

                // Actual computational kernel
                when compute[SDAG_INDEX](int sdag_index,
                    std::vector<std::vector<ct::mat_impl::mat_node>> instr_list, CProxy_set_future proxy) {
                serial "compute_matrix" {

                    update_partitions(instr_list);

                    CkCallback cb(CkReductionTarget(set_future, mark_complete), proxy);
                    contribute(cb);

                    ++SDAG_INDEX;
                }}

                when compute[SDAG_INDEX](int sdag_index,
                    std::vector<std::vector<ct::mat_impl::mat_node>> instr_list) {
                serial "compute_no_proxy_matrix" {

                    update_partitions(instr_list);

                    ++SDAG_INDEX;
                }} // fused compute kernel

                when synchronize[SDAG_INDEX](int sdag_index, CProxy_set_future proxy) {
                serial "synchronize" {
                    CkCallback cb(CkReductionTarget(set_future, mark_complete), proxy);
                    contribute(cb);

                    ++SDAG_INDEX;
                }}

                when mat_vec_dot[SDAG_INDEX](
                    int sdag_index, int mat_idx, int result_sdag_idx,
                    CProxy_vector_impl result_proxy, int result_vec_idx, int result_size) {
                    when receive_to_matrix[SDAG_INDEX](int sdag_idx, int len, double* data)
                serial "mat_vec_dot" {

                    // Get the subvector indices
                    std::size_t block_dim = col_block_len;
                    std::size_t vec_size = block_dim;
                    if (thisIndex.x == num_chares_x - 1 && block_dim % col_block_len != 0) {
                        vec_size = len % col_block_len;
                    }

                    Eigen::Map<Eigen::VectorXd> elhs(data + thisIndex.x * block_dim, vec_size);
                    Eigen::Map<Eigen::MatrixXd> 
                        erhs(mat_map[mat_idx].data(), mat_map[mat_idx].rows(), mat_map[mat_idx].cols());
                    
                    double result[result_size];
                    for (int i = 0; i != result_size; ++i)
                        result[i] = 0;

                    // TODO: Use Paired events (User events). Read docs!
                    traceBeginUserBracketEvent(10);
                    Eigen::Map<Eigen::VectorXd> eres(result + thisIndex.y * row_block_len, mat_map[mat_idx].rows());
                    eres = erhs * elhs;
                    traceEndUserBracketEvent(10);

                    // TODO: Use Section Reduction!
                    CkCallback cb(CkReductionTarget(vector_impl, update_vector), result_proxy);
                    contribute((result_size) * sizeof(double), result, CkReduction::sum_double, cb);

                    ++SDAG_INDEX;
                }} // matrix vector dot product

                when mat_mat_mul[SDAG_INDEX](
                    int sdag_index, int mat_idx, int mat_A_idx, int mat_B_idx) {
                    serial "initial_send" {
                        double* data_A = mat_map[mat_A_idx].data();
                        std::size_t rows_A = mat_map[mat_A_idx].rows();
                        std::size_t cols_A = mat_map[mat_A_idx].cols();
                        thisProxy((thisIndex.x-thisIndex.y+num_chares_y)%num_chares_x, thisIndex.y).inputA(0, data_A, rows_A, cols_A);

                        double* data_B = mat_map[mat_B_idx].data();
                        std::size_t rows_B = mat_map[mat_B_idx].rows();
                        std::size_t cols_B = mat_map[mat_B_idx].cols();
                        thisProxy(thisIndex.x, (thisIndex.y-thisIndex.x+num_chares_x)%num_chares_y).inputB(0, data_B, rows_B, cols_B);
                    }
                    // For all block
                    // FIXME:
                    // Current implementation expects square matrix!
                    forall [block] (0:num_chares_x-1,1) {
                        when
                        inputA[block](int blockIdA, double blockA[M*KA], unsigned int M, unsigned int KA),
                        inputB[block](int blockIdB, double blockB[KB*N], unsigned int KB, unsigned int N)
                        serial "mat_mul_kernel" {
                            CkAssert(KA == KB);

                            Eigen::Map<Eigen::MatrixXd> matA(blockA, M, KA);
                            Eigen::Map<Eigen::MatrixXd> matB(blockB, KB, N);

                            ct::util::matrix_view& result_mat = mat_map[mat_idx];
                            Eigen::Map<Eigen::MatrixXd> matC(result_mat.data(), result_mat.rows(), result_mat.cols());

                            matC += matA * matB;

                            if (blockIdA != num_chares_x) {
                                int destX = (thisIndex.x + 1) % num_chares_x;
                                int destY = thisIndex.y;
                                thisProxy(destX, destY).inputA(blockIdA+1, blockA, M, KA);
                            }
                            if (blockIdB != num_chares_y) {
                                int destX = thisIndex.x;
                                int destY = (thisIndex.y + 1) % num_chares_y;
                                thisProxy(destX, destY).inputB(blockIdB+1, blockB, KB, N);
                            }
                        }
                    }
                    serial "mat_mul_end" {
                        block = 0;
                        ++SDAG_INDEX;
                    }
                }

                when reduce_sum[SDAG_INDEX](int sdag_idx, int matrix_id, int scal_sdag_idx) {
                serial "reduce_sum" {
                    ct::util::matrix_view& lhs = mat_map[matrix_id];

                    Eigen::Map<Eigen::MatrixXd> elhs(lhs.data(), lhs.rows(), lhs.cols());

                    double result = elhs.sum();

                    CkCallback cb(CkReductionTarget(scalar_impl, reduction), scalar_impl_proxy);
                    contribute(sizeof(double), &result, CkReduction::sum_double, cb, scal_sdag_idx);

                    ++SDAG_INDEX;
                }}
            }}
        }

        entry void mat_mat_mul(int, int, int, int);
        entry void inputA(int, double blockA[M*KA], unsigned int M, unsigned int KA);
        entry void inputB(int, double blockB[KB*N], unsigned int KB, unsigned int N);

        entry void generator_init(int, int, int, int, std::shared_ptr<ct::generator>);
        entry void compute(int, std::vector<std::vector<ct::mat_impl::mat_node>>, CProxy_set_future);
        entry void compute(int, std::vector<std::vector<ct::mat_impl::mat_node>>);
        entry void synchronize(int, CProxy_set_future);
        
        entry void mat_vec_dot(int, int, int, CProxy_vector_impl, int, int);
        entry void receive_to_matrix(int, int len, double data[len]);

        entry void reduce_sum(int, int, int);
    }
}
